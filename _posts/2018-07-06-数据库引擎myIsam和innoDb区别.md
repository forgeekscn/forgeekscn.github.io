---
layout:  post
title:		数据库引擎myisam和innoDb区别
subtitle:		数据库引擎myisam和innoDb区别
date:     2018-07-06
author:   Fogeeks
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - MySql
---
 
#	数据库引擎myisam和innoDb区别
 
 mysql默认支持innodb引擎，同时也支持myisam引擎，他们区别是什么，
 首先innodb支持**事务**，myisam不支持
 
 所谓事务指的是要么都执行要么都不执行， **事务四大特性**包括**acid**即原子性一致性隔离性持久性，原子性表示某几个操作必须一起执行不能拆分开，一致性指的是无论是事务成功或者失败系统的状态都必须保持一致，失败会回滚跟之前数据保持一致，成功则所有数据的变化都会被系统应用，隔离性指的是事务正在操作的数据对被其他事务是隔离的，如果不隔离可能多个事务会操作同一个数据，可能造成系统出于不一致状态，持久性代表事务完成对于数据的改变将是永久的。
 
 innodb能加外键，myisam不能
 
 innodb加的是行锁myisam加的是表锁
 
 innodb可以用begin，commit来开启提交事务，他默认的隔离级别是可重复度，有四个隔离级别，分别是串行化，可重复读 ，读提交读，读未提交， 并发性依次升高，数据一致性逐步降低，也就是用破坏数据一致性的代价去获取高并发性能。
 **串行化**就是读写都是串行的，他直接用表级锁，不会有并发冲突，适合数据一致性要求极高的场景，
 **可重复读**就是读的时候可以并行读不能并行写，写还是串行的，且一个事务中读到的数据是事务开始时候的状态
 他性能提高了但代价是会出现**幻读**，由于读写锁会锁住某些已存在的数据来控制读的时候不能写，所以当我这个事务有多个读请求时，另外一个事务向这张表插入几条新的数据并提交，读写锁是锁不住的，因为他是不存在的行，这个时候我的事务再次查数据集可能会凭空多出几条数据，这就是幻读
 **读提交**就是读的时候可以并行读写，写依然是串行的，且一个事务读到的数据是被提交过的
 他性能又提高了但是代价就是既有幻读还有**不可重复读**，不可重复读指的是我这个事务读了一次某行的数据，这时另外一个事务过来写了这行数据并提交了，那么我这个事务再一读就会发现两次数据不一致，这就是不可重复读
 **读未提交**就是读的时候允许读写，写的时候允许读不允许写，且一个事务可以读中间状态的数据即未提交的数据
 并发性能最好数据一致性彻底被破坏，会同时出现幻读不可重复读和**脏读**，脏读就是指我这个事务想读某一行数据，这时候另外一个事务正在修改准备提交，我读出来的就是脏数据，一旦人家修改完了发现不对劲把事务一回滚，就会出现数据不一致的问题
 
 
 
 
 
 
 
 
 
 