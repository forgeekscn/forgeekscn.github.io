---
layout:  post
title:		数据库四大隔离级别及行级锁表级锁
subtitle:		数据库四大隔离级别及行级锁表级锁
date:     2018-07-06
author:   Fogeeks
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - MySql
---
 
#	数据库四大隔离级别及行级锁表级锁
 
 innodb加的是行锁myisam加的是表锁
 
 innodb可以用begin，commit来开启提交事务，他默认的隔离级别是可重复度，有四个隔离级别，分别是串行化，可重复读 ，读提交读，读未提交， 并发性依次升高，数据一致性逐步降低，也就是用破坏数据一致性的代价去获取高并发性能。
 **串行化**就是读写都是串行的，他直接用表级锁，不会有并发冲突，适合数据一致性要求极高的场景，
 **可重复读**就是读的时候可以并行读不能并行写，写还是串行的，且一个事务中读到的数据是事务开始时候的状态
 他性能提高了但代价是会出现**幻读**，由于读写锁会锁住某些已存在的数据来控制读的时候不能写，所以当我这个事务有多个读请求时，另外一个事务向这张表插入几条新的数据并提交，读写锁是锁不住的，因为他是不存在的行，这个时候我的事务再次查数据集可能会凭空多出几条数据，这就是幻读
 **读提交**就是读的时候可以并行读写，写依然是串行的，且一个事务读到的数据是被提交过的
 他性能又提高了但是代价就是既有幻读还有**不可重复读**，不可重复读指的是我这个事务读了一次某行的数据，这时另外一个事务过来写了这行数据并提交了，那么我这个事务再一读就会发现两次数据不一致，这就是不可重复读
 **读未提交**就是读的时候允许读写，写的时候允许读不允许写，且一个事务可以读中间状态的数据即未提交的数据
 并发性能最好数据一致性彻底被破坏，会同时出现幻读不可重复读和**脏读**，脏读就是指我这个事务想读某一行数据，这时候另外一个事务正在修改准备提交，我读出来的就是脏数据，一旦人家修改完了发现不对劲把事务一回滚，就会出现数据不一致的问题
 
 
 
 