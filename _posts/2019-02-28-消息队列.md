---
layout:  post
title:		消息队列
subtitle:		消息队列
date:     2018-12-30
author:   Fogeeks
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - Rabbitmq
    - Kafka
    - 消息队列
---

# 消息队列

- 基础
    - 元数据 ：queue , exchange , binding , virtualhost, node info
- 安装
    - docker pull rabbitmq:3.6.14-management
    ```
        sudo docker run -d  --name rabbitmq-a \
        -p 4669:4369 \
        -p 5671:5671 \
        -p 5672:5672 \
        -p 25672:25672 \
        -p 15672:15672 \
        -h node1 \
        -e RABBITMQ_NODENAME=rabbit \
        -e RABBITMQ_DEFAULT_USER=admin \
        -e RABBITMQ_DEFAULT_PASS=admin \
        -v /usr/local/docker_app/rabbitmq/rabbitmq-a/data:/var/lib/rabbitmq \
        rabbitmq:3.6.14-management

        sudo docker run -d  --name  rabbitmq-b \
        -p 4469:4369 \
        -p 5771:5671 \
        -p 5772:5672 \
        -p 26672:25672 \
        -p 16672:15672 \
        -h node2 \
        -e RABBITMQ_NODENAME=rabbit \
        -e RABBITMQ_DEFAULT_USER=admin \
        -e RABBITMQ_DEFAULT_PASS=admin \
        -v /usr/local/docker_app/rabbitmq/rabbitmq-b/data:/var/lib/rabbitmq \
        rabbitmq:3.6.14-management

        sudo docker  run -d  --name  rabbitmq-c \
        -p 4569:4369 \
        -p 5871:5671 \
        -p 5872:5672 \
        -p 27672:25672 \
        -p 17672:15672 \
        -h node3 \
        -e RABBITMQ_NODENAME=rabbit \
        -e RABBITMQ_DEFAULT_USER=admin \
        -e RABBITMQ_DEFAULT_PASS=admin \
        -v /usr/local/docker_app/rabbitmq/rabbitmq-c/data:/var/lib/rabbitmq \
        rabbitmq:3.6.14-management

        sudo docker create --name rabbitmq-c \
        -p 4569:4369 \
        -p 5871:5671 \
        -p 5872:5672 \
        -p 27672:25672 \
        -p 17672:15672 \
        -h node3 \
        -e RABBITMQ_NODENAME=rabbit \
        -e RABBITMQ_DEFAULT_USER=admin \
        -e RABBITMQ_DEFAULT_PASS=admin \
        -v /usr/local/docker_app/rabbitmq/rabbitmq-c/data:/var/lib/rabbitmq \
        rabbitmq:3.6.14-management
    ```
- 启动
    - sudo docker run -d --hostname rabbit-alone --name rabbit-alone -p 15672:15672 -p 5672:5672  rabbitmq
- 进入对应容器
    - sudo docker exec -it rabbit-alone  /bin/bash
- 场景
    - 异步 如推送提醒消息给用户
    - 解耦 如订单系统库存系统结算系统之间的节藕
    - 肖峰 如高并发场景下请求排队
- 重难点
    - 消息持久化：设置durable为true
    - 消息可靠性：生产者继承confirmCallback,消费者手动ack确认，成功就调用basicack否则调用basicnack

- 常用命令
    - stop restart  => rabbitmq-server –detached   /  rabbitmqctl stop
    - check status => rabbitmqctl status  / rabbitmqctl list_queues  / rabbitmqctl list_exchanges /
    - rabbitmqctl list_bindings /rabbitmqctl list_connections / rabbitmqctl  list_channels
    - clear queues => rabbitmqctl reset
    - add user => sudo rabbitmqctl  add_user  hechao hechao
    - add permission => sudo rabbitmqctl  set_user_tags  hechao administrator

- 引用
    ```
        如何避免消息重复投递或重复消费？
        在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。
    ```
    ```
        如何确保消息不丢失？
        消息持久化的前提是：将交换器/队列的durable属性设置为true，表示交换器/队列是持久交换器/队列，在服务器崩溃或重启之后不需要重新创建交换器/队列（交换器/队列会自动创建）。
        如果消息想要从Rabbit崩溃中恢复，那么消息必须：
        在消息发布前，通过把它的 “投递模式” 选项设置为2（持久）来把消息标记成持久化
        将消息发送到持久交换器
        消息到达持久队列
        RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，Rabbit会在消息提交到日志文件后才发送响应（如果消息路由到了非持久队列，它会自动从持久化日志中移除）。一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前RabbitMQ重启，那么Rabbit会自动重建交换器和队列（以及绑定），并重播持久化日志文件中的消息到合适的队列或者交换器上。
    ```
    ```       
        [为什么使用消息队列？消息队列有什么优点和缺点？Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么优点和缺点？](/docs/high-concurrency/why-mq.md)
        [如何保证消息队列的高可用？](/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md)
        [如何保证消息不被重复消费？（如何保证消息消费时的幂等性）](/docs/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed.md)
        [如何保证消息的可靠性传输？（如何处理消息丢失的问题）](/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages.md)
        [如何保证消息的顺序性？](/docs/high-concurrency/how-to-ensure-the-order-of-messages.md)
        [如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？](/docs/high-concurrency/mq-time-delay-and-expired-failure.md)
    ```





- end
